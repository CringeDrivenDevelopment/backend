// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlaylist = `-- name: CreatePlaylist :exec
INSERT INTO playlists (id, title, thumbnail, tracks, allowed_tracks, type, external_id)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreatePlaylistParams struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
	Type          NullPlaylistType
	ExternalID    pgtype.Text
}

func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) error {
	_, err := q.db.Exec(ctx, createPlaylist,
		arg.ID,
		arg.Title,
		arg.Thumbnail,
		arg.Tracks,
		arg.AllowedTracks,
		arg.Type,
		arg.ExternalID,
	)
	return err
}

const createRole = `-- name: CreateRole :exec
INSERT INTO playlist_permissions (playlist_id, user_id, role)
VALUES ($1, $2, $3)
`

type CreateRoleParams struct {
	PlaylistID string
	UserID     int64
	Role       PlaylistRole
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) error {
	_, err := q.db.Exec(ctx, createRole, arg.PlaylistID, arg.UserID, arg.Role)
	return err
}

const createTrack = `-- name: CreateTrack :exec
INSERT INTO tracks (id, title, authors, thumbnail, length, explicit)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateTrackParams struct {
	ID        string
	Title     string
	Authors   string
	Thumbnail string
	Length    int32
	Explicit  bool
}

func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) error {
	_, err := q.db.Exec(ctx, createTrack,
		arg.ID,
		arg.Title,
		arg.Authors,
		arg.Thumbnail,
		arg.Length,
		arg.Explicit,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id) VALUES ($1)
`

func (q *Queries) CreateUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, createUser, id)
	return err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists WHERE id = $1
`

func (q *Queries) DeletePlaylist(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePlaylist, id)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM playlist_permissions
WHERE playlist_id = $1 AND user_id = $2
`

type DeleteRoleParams struct {
	PlaylistID string
	UserID     int64
}

func (q *Queries) DeleteRole(ctx context.Context, arg DeleteRoleParams) error {
	_, err := q.db.Exec(ctx, deleteRole, arg.PlaylistID, arg.UserID)
	return err
}

const editPlaylist = `-- name: EditPlaylist :exec
UPDATE playlists
SET
    title = COALESCE($2, title),
    thumbnail = COALESCE($3, thumbnail),
    tracks = COALESCE($4, tracks),
    allowed_tracks = COALESCE($5, allowed_tracks),
    type = COALESCE($6, type),
    external_id = COALESCE($7, external_id)
WHERE id = $1
`

type EditPlaylistParams struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
	Type          NullPlaylistType
	ExternalID    pgtype.Text
}

func (q *Queries) EditPlaylist(ctx context.Context, arg EditPlaylistParams) error {
	_, err := q.db.Exec(ctx, editPlaylist,
		arg.ID,
		arg.Title,
		arg.Thumbnail,
		arg.Tracks,
		arg.AllowedTracks,
		arg.Type,
		arg.ExternalID,
	)
	return err
}

const editRole = `-- name: EditRole :exec
UPDATE playlist_permissions
SET role = $3
WHERE playlist_id = $1 AND user_id = $2
`

type EditRoleParams struct {
	PlaylistID string
	UserID     int64
	Role       PlaylistRole
}

func (q *Queries) EditRole(ctx context.Context, arg EditRoleParams) error {
	_, err := q.db.Exec(ctx, editRole, arg.PlaylistID, arg.UserID, arg.Role)
	return err
}

const getPlaylistById = `-- name: GetPlaylistById :one
SELECT
    pl.id, pl.title, pl.thumbnail, pl.type, pl.external_id, pl.tracks, pl.allowed_tracks, pl.count, pl.allowed_count, pl.time,
    p.role
FROM playlist_permissions p
         JOIN playlists pl ON p.playlist_id = pl.id
         JOIN users u ON p.user_id = u.id  -- Join users table
WHERE p.playlist_id = $1 AND  p.user_id = $2
`

type GetPlaylistByIdParams struct {
	PlaylistID string
	UserID     int64
}

type GetPlaylistByIdRow struct {
	ID            string
	Title         string
	Thumbnail     string
	Type          NullPlaylistType
	ExternalID    pgtype.Text
	Tracks        []string
	AllowedTracks []string
	Count         pgtype.Int4
	AllowedCount  pgtype.Int4
	Time          int32
	Role          PlaylistRole
}

func (q *Queries) GetPlaylistById(ctx context.Context, arg GetPlaylistByIdParams) (GetPlaylistByIdRow, error) {
	row := q.db.QueryRow(ctx, getPlaylistById, arg.PlaylistID, arg.UserID)
	var i GetPlaylistByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Thumbnail,
		&i.Type,
		&i.ExternalID,
		&i.Tracks,
		&i.AllowedTracks,
		&i.Count,
		&i.AllowedCount,
		&i.Time,
		&i.Role,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT playlist_id FROM playlist_permissions
WHERE user_id = $1 AND role = $2
`

type GetRoleParams struct {
	UserID int64
	Role   PlaylistRole
}

func (q *Queries) GetRole(ctx context.Context, arg GetRoleParams) (string, error) {
	row := q.db.QueryRow(ctx, getRole, arg.UserID, arg.Role)
	var playlist_id string
	err := row.Scan(&playlist_id)
	return playlist_id, err
}

const getTrackById = `-- name: GetTrackById :one
SELECT id, title, authors, thumbnail, length, explicit FROM tracks WHERE id = $1
`

func (q *Queries) GetTrackById(ctx context.Context, id string) (Track, error) {
	row := q.db.QueryRow(ctx, getTrackById, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Authors,
		&i.Thumbnail,
		&i.Length,
		&i.Explicit,
	)
	return i, err
}

const getTrackPlaylists = `-- name: GetTrackPlaylists :many
SELECT pl.id
FROM playlists pl
         JOIN playlist_permissions pp ON pl.id = pp.playlist_id
WHERE
    pp.user_id = $1
  AND $2::text = ANY(pl.tracks)
`

type GetTrackPlaylistsParams struct {
	UserID  int64
	TrackID string
}

// param: TrackId text
// param: UserId bigint
func (q *Queries) GetTrackPlaylists(ctx context.Context, arg GetTrackPlaylistsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getTrackPlaylists, arg.UserID, arg.TrackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	err := row.Scan(&id)
	return id, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT
    pl.id, pl.title, pl.thumbnail, pl.type, pl.external_id, pl.tracks, pl.allowed_tracks, pl.count, pl.allowed_count, pl.time,
    p.role
FROM playlists pl
         JOIN playlist_permissions p ON pl.id = p.playlist_id
         JOIN users u ON p.user_id = u.id  -- Join users table
WHERE p.user_id = $1
`

type GetUserPlaylistsRow struct {
	ID            string
	Title         string
	Thumbnail     string
	Type          NullPlaylistType
	ExternalID    pgtype.Text
	Tracks        []string
	AllowedTracks []string
	Count         pgtype.Int4
	AllowedCount  pgtype.Int4
	Time          int32
	Role          PlaylistRole
}

func (q *Queries) GetUserPlaylists(ctx context.Context, userID int64) ([]GetUserPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPlaylistsRow
	for rows.Next() {
		var i GetUserPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Thumbnail,
			&i.Type,
			&i.ExternalID,
			&i.Tracks,
			&i.AllowedTracks,
			&i.Count,
			&i.AllowedCount,
			&i.Time,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
