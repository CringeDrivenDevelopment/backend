// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: schema.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlaylist = `-- name: CreatePlaylist :exec





INSERT INTO playlists (id, title, thumbnail, tracks, allowed_tracks, type)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreatePlaylistParams struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
	Type          string
}

// INIT DATABASE TABLES / SCHEMA END
// =================================
// PLAYLISTS CRUD BEGIN
func (q *Queries) CreatePlaylist(ctx context.Context, arg CreatePlaylistParams) error {
	_, err := q.db.Exec(ctx, createPlaylist,
		arg.ID,
		arg.Title,
		arg.Thumbnail,
		arg.Tracks,
		arg.AllowedTracks,
		arg.Type,
	)
	return err
}

const createRole = `-- name: CreateRole :exec





INSERT INTO playlist_permissions (playlist_id, user_id, role)
VALUES ($1, $2, $3)
`

type CreateRoleParams struct {
	PlaylistID string
	UserID     int64
	Role       string
}

// TRACKS CRUD END
// =================================
// ROLES CRUD BEGIN
func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) error {
	_, err := q.db.Exec(ctx, createRole, arg.PlaylistID, arg.UserID, arg.Role)
	return err
}

const createTrack = `-- name: CreateTrack :exec





INSERT INTO tracks (id, title, authors, thumbnail, length, explicit)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateTrackParams struct {
	ID        string
	Title     string
	Authors   string
	Thumbnail string
	Length    int32
	Explicit  bool
}

// USERS CRUD END
// =================================
// TRACKS CRUD BEGIN
func (q *Queries) CreateTrack(ctx context.Context, arg CreateTrackParams) error {
	_, err := q.db.Exec(ctx, createTrack,
		arg.ID,
		arg.Title,
		arg.Authors,
		arg.Thumbnail,
		arg.Length,
		arg.Explicit,
	)
	return err
}

const createUser = `-- name: CreateUser :exec





INSERT INTO users (id, name) VALUES ($1, $2)
`

type CreateUserParams struct {
	ID   int64
	Name string
}

// PLAYLISTS CRUD END
// =================================
// USERS CRUD BEGIN
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser, arg.ID, arg.Name)
	return err
}

const deletePlaylist = `-- name: DeletePlaylist :exec
DELETE FROM playlists WHERE id = $1
`

func (q *Queries) DeletePlaylist(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deletePlaylist, id)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM playlist_permissions
WHERE playlist_id = $1 AND user_id = $2
`

type DeleteRoleParams struct {
	PlaylistID string
	UserID     int64
}

func (q *Queries) DeleteRole(ctx context.Context, arg DeleteRoleParams) error {
	_, err := q.db.Exec(ctx, deleteRole, arg.PlaylistID, arg.UserID)
	return err
}

const editPlaylist = `-- name: EditPlaylist :exec
UPDATE playlists
SET
    title = COALESCE($2, title),
    thumbnail = COALESCE($3, thumbnail),
    tracks = COALESCE($4, tracks),
    allowed_tracks = COALESCE($5, allowed_tracks),
    type = COALESCE($6, type)
WHERE id = $1
`

type EditPlaylistParams struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
	Type          string
}

func (q *Queries) EditPlaylist(ctx context.Context, arg EditPlaylistParams) error {
	_, err := q.db.Exec(ctx, editPlaylist,
		arg.ID,
		arg.Title,
		arg.Thumbnail,
		arg.Tracks,
		arg.AllowedTracks,
		arg.Type,
	)
	return err
}

const editRole = `-- name: EditRole :exec
UPDATE playlist_permissions
SET role = $3
WHERE playlist_id = $1 AND user_id = $2
`

type EditRoleParams struct {
	PlaylistID string
	UserID     int64
	Role       string
}

func (q *Queries) EditRole(ctx context.Context, arg EditRoleParams) error {
	_, err := q.db.Exec(ctx, editRole, arg.PlaylistID, arg.UserID, arg.Role)
	return err
}

const editUser = `-- name: EditUser :exec
UPDATE users SET name = $2 WHERE id = $1
`

type EditUserParams struct {
	ID   int64
	Name string
}

func (q *Queries) EditUser(ctx context.Context, arg EditUserParams) error {
	_, err := q.db.Exec(ctx, editUser, arg.ID, arg.Name)
	return err
}

const getPlaylistById = `-- name: GetPlaylistById :one
SELECT
    pl.id, pl.title, pl.thumbnail, pl.tracks, pl.allowed_tracks, pl.count, pl.allowed_count, pl.type, pl.time, pl.allowed_time,
    p.role
FROM playlist_permissions p
         JOIN playlists pl ON p.playlist_id = pl.id
         JOIN users u ON p.user_id = u.id  -- Join users table
WHERE p.playlist_id = $1 AND  p.user_id = $2
`

type GetPlaylistByIdParams struct {
	PlaylistID string
	UserID     int64
}

type GetPlaylistByIdRow struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
	Count         pgtype.Int4
	AllowedCount  pgtype.Int4
	Type          string
	Time          int32
	AllowedTime   int32
	Role          string
}

func (q *Queries) GetPlaylistById(ctx context.Context, arg GetPlaylistByIdParams) (GetPlaylistByIdRow, error) {
	row := q.db.QueryRow(ctx, getPlaylistById, arg.PlaylistID, arg.UserID)
	var i GetPlaylistByIdRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Thumbnail,
		&i.Tracks,
		&i.AllowedTracks,
		&i.Count,
		&i.AllowedCount,
		&i.Type,
		&i.Time,
		&i.AllowedTime,
		&i.Role,
	)
	return i, err
}

const getTrackById = `-- name: GetTrackById :one
SELECT id, title, authors, thumbnail, length, explicit FROM tracks WHERE id = $1
`

func (q *Queries) GetTrackById(ctx context.Context, id string) (Track, error) {
	row := q.db.QueryRow(ctx, getTrackById, id)
	var i Track
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Authors,
		&i.Thumbnail,
		&i.Length,
		&i.Explicit,
	)
	return i, err
}

const getTrackPlaylists = `-- name: GetTrackPlaylists :many
SELECT pl.id
FROM playlists pl
         JOIN playlist_permissions pp ON pl.id = pp.playlist_id
WHERE
    pp.user_id = $1
  AND $2::text = ANY(pl.tracks)
`

type GetTrackPlaylistsParams struct {
	UserID  int64
	TrackID string
}

// param: TrackId text
// param: UserId bigint
func (q *Queries) GetTrackPlaylists(ctx context.Context, arg GetTrackPlaylistsParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getTrackPlaylists, arg.UserID, arg.TrackID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, name FROM users WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getUserPlaylists = `-- name: GetUserPlaylists :many
SELECT
    pl.id, pl.title, pl.thumbnail, pl.tracks, pl.allowed_tracks, pl.count, pl.allowed_count, pl.type, pl.time, pl.allowed_time,
    p.role
FROM playlists pl
         JOIN playlist_permissions p ON pl.id = p.playlist_id
         JOIN users u ON p.user_id = u.id  -- Join users table
WHERE p.user_id = $1
`

type GetUserPlaylistsRow struct {
	ID            string
	Title         string
	Thumbnail     string
	Tracks        []string
	AllowedTracks []string
	Count         pgtype.Int4
	AllowedCount  pgtype.Int4
	Type          string
	Time          int32
	AllowedTime   int32
	Role          string
}

func (q *Queries) GetUserPlaylists(ctx context.Context, userID int64) ([]GetUserPlaylistsRow, error) {
	rows, err := q.db.Query(ctx, getUserPlaylists, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPlaylistsRow
	for rows.Next() {
		var i GetUserPlaylistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Thumbnail,
			&i.Tracks,
			&i.AllowedTracks,
			&i.Count,
			&i.AllowedCount,
			&i.Type,
			&i.Time,
			&i.AllowedTime,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initCalculatePlaylistTime = `-- name: InitCalculatePlaylistTime :exec
CREATE OR REPLACE FUNCTION calculate_playlist_time(track_ids TEXT[])
    RETURNS INTEGER AS $$
DECLARE
    total_time INTEGER;
BEGIN
    SELECT COALESCE(SUM(length), 0) INTO total_time
    FROM tracks
    WHERE id = ANY(track_ids);

    RETURN total_time;
END;
$$ LANGUAGE plpgsql
`

func (q *Queries) InitCalculatePlaylistTime(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initCalculatePlaylistTime)
	return err
}

const initPermissions = `-- name: InitPermissions :exec
CREATE TABLE IF NOT EXISTS playlist_permissions (
    playlist_id TEXT NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
    user_id BIGINT NOT NULL REFERENCES users(id),
    role TEXT NOT NULL,
    PRIMARY KEY (playlist_id, user_id)
)
`

func (q *Queries) InitPermissions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPermissions)
	return err
}

const initPermissionsIndex = `-- name: InitPermissionsIndex :exec
CREATE INDEX IF NOT EXISTS idx_permissions_user ON playlist_permissions (user_id)
`

func (q *Queries) InitPermissionsIndex(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPermissionsIndex)
	return err
}

const initPlaylistTimesTrigger = `-- name: InitPlaylistTimesTrigger :exec
DO $$
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM pg_trigger
            WHERE tgname = 'playlist_times_trigger'
        ) THEN
            CREATE TRIGGER playlist_times_trigger
                BEFORE INSERT OR UPDATE OF tracks, allowed_tracks ON playlists
                FOR EACH ROW
            EXECUTE FUNCTION update_playlist_times();
        END IF;
    END
$$
`

func (q *Queries) InitPlaylistTimesTrigger(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPlaylistTimesTrigger)
	return err
}

const initPlaylists = `-- name: InitPlaylists :exec

CREATE TABLE IF NOT EXISTS playlists (
    id TEXT NOT NULL PRIMARY KEY UNIQUE,
    title TEXT NOT NULL,
    thumbnail TEXT NOT NULL,
    tracks TEXT[] DEFAULT '{}',
    allowed_tracks TEXT[] DEFAULT '{}',
    count INTEGER GENERATED ALWAYS AS (COALESCE(array_length(tracks, 1), 0)) STORED,
    allowed_count INTEGER GENERATED ALWAYS AS (COALESCE(array_length(allowed_tracks, 1), 0)) STORED,
    type TEXT NOT NULL,
    time INTEGER NOT NULL DEFAULT 0,
    allowed_time INTEGER NOT NULL DEFAULT 0
)
`

// INIT DATABASE TABLES / SCHEMA BEGIN
func (q *Queries) InitPlaylists(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPlaylists)
	return err
}

const initPlaylistsAllowedTracksIndex = `-- name: InitPlaylistsAllowedTracksIndex :exec
CREATE INDEX IF NOT EXISTS idx_playlists_allowed_tracks ON playlists USING GIN(allowed_tracks)
`

func (q *Queries) InitPlaylistsAllowedTracksIndex(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPlaylistsAllowedTracksIndex)
	return err
}

const initPlaylistsTracksIndex = `-- name: InitPlaylistsTracksIndex :exec
CREATE INDEX IF NOT EXISTS idx_playlists_tracks ON playlists USING GIN(tracks)
`

func (q *Queries) InitPlaylistsTracksIndex(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initPlaylistsTracksIndex)
	return err
}

const initTrackUpdate = `-- name: InitTrackUpdate :exec
DO $$
    BEGIN
        IF NOT EXISTS (
            SELECT 1 FROM pg_trigger
            WHERE tgname = 'track_update_trigger'
        ) THEN
            CREATE TRIGGER track_update_trigger
                AFTER INSERT OR UPDATE OF length ON tracks
                FOR EACH ROW
            EXECUTE FUNCTION update_playlists_on_track_change();
        END IF;
    END
$$
`

func (q *Queries) InitTrackUpdate(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initTrackUpdate)
	return err
}

const initTracks = `-- name: InitTracks :exec
CREATE TABLE IF NOT EXISTS tracks (
    id TEXT NOT NULL PRIMARY KEY,
    title TEXT NOT NULL,
    authors TEXT NOT NULL,
    thumbnail TEXT NOT NULL,
    length INTEGER NOT NULL,
    explicit BOOLEAN NOT NULL DEFAULT FALSE
)
`

func (q *Queries) InitTracks(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initTracks)
	return err
}

const initTracksIndex = `-- name: InitTracksIndex :exec
CREATE INDEX IF NOT EXISTS idx_tracks_id ON tracks (id)
`

func (q *Queries) InitTracksIndex(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initTracksIndex)
	return err
}

const initUpdatePlaylistOnTrackChange = `-- name: InitUpdatePlaylistOnTrackChange :exec
CREATE OR REPLACE FUNCTION update_playlists_on_track_change()
    RETURNS TRIGGER AS $$
BEGIN
    UPDATE playlists
    SET time = calculate_playlist_time(tracks)
    WHERE NEW.id = ANY(tracks);

    UPDATE playlists
    SET allowed_time = calculate_playlist_time(allowed_tracks)
    WHERE NEW.id = ANY(allowed_tracks);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql
`

func (q *Queries) InitUpdatePlaylistOnTrackChange(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initUpdatePlaylistOnTrackChange)
	return err
}

const initUpdatePlaylistTimes = `-- name: InitUpdatePlaylistTimes :exec
CREATE OR REPLACE FUNCTION update_playlist_times()
    RETURNS TRIGGER AS $$
BEGIN
    NEW.time = calculate_playlist_time(NEW.tracks);

    NEW.allowed_time = calculate_playlist_time(NEW.allowed_tracks);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql
`

func (q *Queries) InitUpdatePlaylistTimes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initUpdatePlaylistTimes)
	return err
}

const initUsers = `-- name: InitUsers :exec
CREATE TABLE IF NOT EXISTS users (
    id BIGINT NOT NULL PRIMARY KEY,
    name TEXT NOT NULL
)
`

func (q *Queries) InitUsers(ctx context.Context) error {
	_, err := q.db.Exec(ctx, initUsers)
	return err
}
